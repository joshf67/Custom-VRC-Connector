{
  "api/Joshf67.ServerConnector.Connector.html": {
    "href": "api/Joshf67.ServerConnector.Connector.html",
    "title": "Class Connector | Server Connector documentation",
    "keywords": "Class Connector Abstract base class to enable easy connections to servers Inheritance Object Connector Namespace : Joshf67.ServerConnector Assembly : cs.temp.dll.dll Syntax public abstract class Connector : UdonSharpBehaviour Fields messageTypeSize Controls how many bits are used for specifying the message type Declaration protected byte messageTypeSize Field Value Type Description Byte packingMessageBitSize Controls how many bits are packed into each message Declaration protected byte packingMessageBitSize Field Value Type Description Byte Methods AddMessagesToBuffer(DataList) Adds multiple messages to the buffer to be sent (usually batched with a single response type on the first message) Declaration public void AddMessagesToBuffer(DataList messages) Parameters Type Name Description DataList messages The messages to add AddMessageToBuffer(Int32) Adds a single message to the buffer to be sent Declaration public void AddMessageToBuffer(int message) Parameters Type Name Description Int32 message The message to add HandleMessage(String) Required function for any children to implement to recieve messages Declaration public abstract void HandleMessage(string response) Parameters Type Name Description String response The server XML response ManagerStart() Virtual function for any children to add onto the Start function Declaration protected virtual void ManagerStart() ManagerUpdate() Virtual function for any children to add onto the Update function Declaration protected virtual void ManagerUpdate() Start() Setup all the required downloader variables when initiated Declaration public void Start()"
  },
  "api/Joshf67.ServerConnector.ConnectorMessageType.html": {
    "href": "api/Joshf67.ServerConnector.ConnectorMessageType.html",
    "title": "Enum ConnectorMessageType | Server Connector documentation",
    "keywords": "Enum ConnectorMessageType Used so the server can understand what is supposed to happen for a response Namespace : Joshf67.ServerConnector Assembly : cs.temp.dll.dll Syntax public enum ConnectorMessageType Fields Name Description AccountCreation Any messages relating to account creation AcknowledgeMessage A message reserved for acknowledging that the user still exists GeneralMessage Any general messages Invalid The default value, will fail to send Login Any messages relating to logging in MessageFinished A message reserved for any variable length data that can't be calculated ModifyItem Any item related messages"
  },
  "api/Joshf67.ServerConnector.Development.DevelopmentManager.html": {
    "href": "api/Joshf67.ServerConnector.Development.DevelopmentManager.html",
    "title": "Class DevelopmentManager | Server Connector documentation",
    "keywords": "Class DevelopmentManager Used to control the development modes of different classes all in one spot Inheritance Object DevelopmentManager Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Joshf67.ServerConnector.Development Assembly : cs.temp.dll.dll Syntax public static class DevelopmentManager Fields ByteConverterMode Stores the current development mode for the ByteConverter Declaration public const DevelopmentMode ByteConverterMode = DevelopmentMode.None Field Value Type Description DevelopmentMode ConnectorMode Stores the current development mode for the Connector Declaration public const DevelopmentMode ConnectorMode = DevelopmentMode.None Field Value Type Description DevelopmentMode ImageListenerMode Stores the current development mode for the ImageListener Declaration public const DevelopmentMode ImageListenerMode = DevelopmentMode.None Field Value Type Description DevelopmentMode MessagePackerMode Stores the current development mode for the MessagePacker Declaration public const DevelopmentMode MessagePackerMode = DevelopmentMode.None Field Value Type Description DevelopmentMode SchemaMode Stores the current development mode for the Schema Declaration public const DevelopmentMode SchemaMode = DevelopmentMode.None Field Value Type Description DevelopmentMode ServerResponseMode Stores the current development mode for the ServerResponse Declaration public const DevelopmentMode ServerResponseMode = DevelopmentMode.None Field Value Type Description DevelopmentMode StringListenerMode Stores the current development mode for the StringListener Declaration public const DevelopmentMode StringListenerMode = DevelopmentMode.None Field Value Type Description DevelopmentMode Methods IsByteConverterEnabled(DevelopmentMode) Tests if the development mode for Converter is enabled Declaration public static bool IsByteConverterEnabled(DevelopmentMode mode) Parameters Type Name Description DevelopmentMode mode The mode to test for Returns Type Description Boolean If the current mode is the same, or all is selected IsConnectorEnabled(DevelopmentMode) Tests if the development mode for Connector is enabled Declaration public static bool IsConnectorEnabled(DevelopmentMode mode) Parameters Type Name Description DevelopmentMode mode The mode to test for Returns Type Description Boolean If the current mode is the same, or all is selected IsImageListenerEnabled(DevelopmentMode) Tests if the development mode for ImageListener is enabled Declaration public static bool IsImageListenerEnabled(DevelopmentMode mode) Parameters Type Name Description DevelopmentMode mode The mode to test for Returns Type Description Boolean If the current mode is the same, or all is selected IsMessagePackerEnabled(DevelopmentMode) Tests if the development mode for MessagePacker is enabled Declaration public static bool IsMessagePackerEnabled(DevelopmentMode mode) Parameters Type Name Description DevelopmentMode mode The mode to test for Returns Type Description Boolean If the current mode is the same, or all is selected IsSchemaEnabled(DevelopmentMode) Tests if the development mode for Schema is enabled Declaration public static bool IsSchemaEnabled(DevelopmentMode mode) Parameters Type Name Description DevelopmentMode mode The mode to test for Returns Type Description Boolean If the current mode is the same, or all is selected IsServerResponseEnabled(DevelopmentMode) Tests if the development mode for ServerResponse is enabled Declaration public static bool IsServerResponseEnabled(DevelopmentMode mode) Parameters Type Name Description DevelopmentMode mode The mode to test for Returns Type Description Boolean If the current mode is the same, or all is selected IsStringListenerEnabled(DevelopmentMode) Tests if the development mode for StringListener is enabled Declaration public static bool IsStringListenerEnabled(DevelopmentMode mode) Parameters Type Name Description DevelopmentMode mode The mode to test for Returns Type Description Boolean If the current mode is the same, or all is selected"
  },
  "api/Joshf67.ServerConnector.Development.DevelopmentMode.html": {
    "href": "api/Joshf67.ServerConnector.Development.DevelopmentMode.html",
    "title": "Enum DevelopmentMode | Server Connector documentation",
    "keywords": "Enum DevelopmentMode Used to control the depth of debugging Namespace : Joshf67.ServerConnector.Development Assembly : cs.temp.dll.dll Syntax public enum DevelopmentMode Fields Name Description Advanced Indicates advanced development mode is enabled All Indicates all development modes are enabled Basic Indicates basic development mode is enabled None Indicates no development mode is enabled Warning Indicates that error development modes are enabled"
  },
  "api/Joshf67.ServerConnector.Development.html": {
    "href": "api/Joshf67.ServerConnector.Development.html",
    "title": "Namespace Joshf67.ServerConnector.Development | Server Connector documentation",
    "keywords": "Namespace Joshf67.ServerConnector.Development Classes DevelopmentManager Used to control the development modes of different classes all in one spot Enums DevelopmentMode Used to control the depth of debugging"
  },
  "api/Joshf67.ServerConnector.Downloader.ConnectorUrlTool.html": {
    "href": "api/Joshf67.ServerConnector.Downloader.ConnectorUrlTool.html",
    "title": "Class ConnectorUrlTool | Server Connector documentation",
    "keywords": "Class ConnectorUrlTool Used to store all of the URLs to connect to a server Inheritance Object ConnectorUrlTool Namespace : Joshf67.ServerConnector.Downloader Assembly : cs.temp.dll.dll Syntax public class ConnectorUrlTool : UdonSharpBehaviour Fields urls Stores any of the URLs on this object Declaration public VRCUrl[] urls Field Value Type Description VRCUrl [] Methods ConvertMessageToVRCUrl(Int32) Convert an input into the correct URL object Declaration public VRCUrl ConvertMessageToVRCUrl(int input) Parameters Type Name Description Int32 input The URL/message to send Returns Type Description VRCUrl A VRC URL with the message encoded"
  },
  "api/Joshf67.ServerConnector.Downloader.ConnectorUrlToolManager.html": {
    "href": "api/Joshf67.ServerConnector.Downloader.ConnectorUrlToolManager.html",
    "title": "Class ConnectorUrlToolManager | Server Connector documentation",
    "keywords": "Class ConnectorUrlToolManager Used to store all of the sub URL containers to enable better VRC world build speed Inheritance Object ConnectorUrlToolManager Namespace : Joshf67.ServerConnector.Downloader Assembly : cs.temp.dll.dll Syntax public class ConnectorUrlToolManager : UdonSharpBehaviour Fields urlCollections Contains every URL container assosiated with this manager Declaration public ConnectorUrlTool[] urlCollections Field Value Type Description ConnectorUrlTool [] urlCount The total URLs currently stored/generated Declaration public int urlCount Field Value Type Description Int32 urlPrefix The starting URL prefix for messages Declaration public string urlPrefix Field Value Type Description String Methods ConvertMessageToVRCUrl(Int32) Converts an int into the correct URL container index and requests the URL from it Declaration public VRCUrl ConvertMessageToVRCUrl(int input) Parameters Type Name Description Int32 input The VRCUrl index to look for Returns Type Description VRCUrl A VRCUrl with the input message"
  },
  "api/Joshf67.ServerConnector.Downloader.DownloaderMessageStatus.html": {
    "href": "api/Joshf67.ServerConnector.Downloader.DownloaderMessageStatus.html",
    "title": "Enum DownloaderMessageStatus | Server Connector documentation",
    "keywords": "Enum DownloaderMessageStatus Used to determine what response was recieved from Namespace : Joshf67.ServerConnector.Downloader Assembly : cs.temp.dll.dll Syntax public enum DownloaderMessageStatus Fields Name Description Awaiting_Request The downloader is awaiting a response from the server Failed_To_Send The downloader failed to connect to the server Message_Sent The downloader successfully sent a message Request_Error The server responded with an error Server_Error The downloader failed to connect to the server Type_Fail The server responded with an invalid type response Unexpected_Request User_Not_Logged_In The server responded with a user not logged in response"
  },
  "api/Joshf67.ServerConnector.Downloader.html": {
    "href": "api/Joshf67.ServerConnector.Downloader.html",
    "title": "Namespace Joshf67.ServerConnector.Downloader | Server Connector documentation",
    "keywords": "Namespace Joshf67.ServerConnector.Downloader Classes ConnectorUrlTool Used to store all of the URLs to connect to a server ConnectorUrlToolManager Used to store all of the sub URL containers to enable better VRC world build speed ImageDownloaderListener This class was generated to solve an error with the Image Downloader where it can read erros from different threads The solution was to extract the onsuccess/onerror to another script and report back to the main script This is no longer needed however does split up the code for downloaders and connectors StringDownloaderListener This class was generated because of an issue with the Image Downloader where it can read erros from different threads, The solution was to extract the onsuccess/onerror to another script and report back to the main script. This is no longer needed however does split up the code for downloaders and connectors Enums DownloaderMessageStatus Used to determine what response was recieved from"
  },
  "api/Joshf67.ServerConnector.Downloader.ImageDownloaderListener.html": {
    "href": "api/Joshf67.ServerConnector.Downloader.ImageDownloaderListener.html",
    "title": "Class ImageDownloaderListener | Server Connector documentation",
    "keywords": "Class ImageDownloaderListener This class was generated to solve an error with the Image Downloader where it can read erros from different threads The solution was to extract the onsuccess/onerror to another script and report back to the main script This is no longer needed however does split up the code for downloaders and connectors Inheritance Object ImageDownloaderListener Namespace : Joshf67.ServerConnector.Downloader Assembly : cs.temp.dll.dll Syntax public class ImageDownloaderListener : UdonSharpBehaviour Fields DownloaderStatus Stores if a message has recieved a response from a server Declaration public DownloaderMessageStatus DownloaderStatus Field Value Type Description DownloaderMessageStatus Methods OnImageLoadError(IVRCImageDownload) Image downloader is used purely to decrease response time, no result handling is needed Declaration public override void OnImageLoadError(IVRCImageDownload result) Parameters Type Name Description IVRCImageDownload result The response from a server OnImageLoadSuccess(IVRCImageDownload) Image downloader is used purely to decrease response time, no result handling is needed Declaration public override void OnImageLoadSuccess(IVRCImageDownload result) Parameters Type Name Description IVRCImageDownload result The response from a server"
  },
  "api/Joshf67.ServerConnector.Downloader.StringDownloaderListener.html": {
    "href": "api/Joshf67.ServerConnector.Downloader.StringDownloaderListener.html",
    "title": "Class StringDownloaderListener | Server Connector documentation",
    "keywords": "Class StringDownloaderListener This class was generated because of an issue with the Image Downloader where it can read erros from different threads, The solution was to extract the onsuccess/onerror to another script and report back to the main script. This is no longer needed however does split up the code for downloaders and connectors Inheritance Object StringDownloaderListener Namespace : Joshf67.ServerConnector.Downloader Assembly : cs.temp.dll.dll Syntax public class StringDownloaderListener : UdonSharpBehaviour Fields DownloaderStatus Stores if a message has recieved a response from a server Declaration public DownloaderMessageStatus DownloaderStatus Field Value Type Description DownloaderMessageStatus Properties RequestResult Public getter for the last recieved response Declaration public IVRCStringDownload RequestResult { get; } Property Value Type Description IVRCStringDownload Methods OnStringLoadError(IVRCStringDownload) Handle String Downloader error message Declaration public override void OnStringLoadError(IVRCStringDownload result) Parameters Type Name Description IVRCStringDownload result The response from the server OnStringLoadSuccess(IVRCStringDownload) Handle String Downloader successful message Declaration public override void OnStringLoadSuccess(IVRCStringDownload result) Parameters Type Name Description IVRCStringDownload result The response from the server"
  },
  "api/Joshf67.ServerConnector.html": {
    "href": "api/Joshf67.ServerConnector.html",
    "title": "Namespace Joshf67.ServerConnector | Server Connector documentation",
    "keywords": "Namespace Joshf67.ServerConnector Classes Connector Abstract base class to enable easy connections to servers Enums ConnectorMessageType Used so the server can understand what is supposed to happen for a response"
  },
  "api/Joshf67.ServerConnector.Packing.ByteConverter.html": {
    "href": "api/Joshf67.ServerConnector.Packing.ByteConverter.html",
    "title": "Class ByteConverter | Server Connector documentation",
    "keywords": "Class ByteConverter This class is a one-way converter to byte arrays, it doesn't not have a way to revert this This class is not optimized with generic objects so use DataTokens due to using typeof search which means we can't use switches because it's not const This is class is a combination of two different methods of converting to make generating server requests easier. https://github.com/Xytabich/UNet/blob/master/UNet/ByteBufferWriter.cs https://github.com/Miner28/NetworkedEventCaller Inheritance Object ByteConverter Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Joshf67.ServerConnector.Packing Assembly : cs.temp.dll.dll Syntax public class ByteConverter Methods ConvertASCIIString(String) Convert a ASCII string to a DataList Byte Array Declaration public static DataList ConvertASCIIString(string value) Parameters Type Name Description String value The ASCII String to convert Returns Type Description DataList A DataList Byte Array with the same length as the string ConvertASCIIStrings(String[]) Convert ASCII strings to a DataList Array Declaration public static DataList ConvertASCIIStrings(string[] value) Parameters Type Name Description String [] value The ASCII strings to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertBool(Boolean) Convert a Boolean to a DataList Byte Array Declaration public static DataList ConvertBool(bool value) Parameters Type Name Description Boolean value The boolean to convert Returns Type Description DataList A single DataList Byte Array ConvertBools(Boolean[]) Convert Booleans to a DataList Array Declaration public static DataList ConvertBools(bool[] value) Parameters Type Name Description Boolean [] value The boolean to convert Returns Type Description DataList A DataList containing the individual converted results ConvertByte(Byte) Convert a Byte to a DataList Byte Array Declaration public static DataList ConvertByte(byte value) Parameters Type Name Description Byte value The boolean to convert Returns Type Description DataList A single DataList Byte Array ConvertBytes(Byte[]) Convert bytes to a DataList Byte Array Declaration public static DataList ConvertBytes(byte[] value) Parameters Type Name Description Byte [] value The byte array to convert Returns Type Description DataList A DataList Byte Array ConvertChar(Char) Convert a Char to a DataList Byte Array Declaration public static DataList ConvertChar(char value) Parameters Type Name Description Char value The char to convert Returns Type Description DataList A 2 DataList Byte Array ConvertChars(Char[]) Convert Chars to a DataList Array Declaration public static DataList ConvertChars(char[] value) Parameters Type Name Description Char [] value The chars to convert Returns Type Description DataList A DataList containing the individual converted results ConvertColor(Color) Convert a Color to a DataList Byte Array Declaration public static DataList ConvertColor(Color value) Parameters Type Name Description Color value The Color to convert Returns Type Description DataList A 4 DataList Byte Array ConvertColor32(Color32) Convert a Color32 to a DataList Byte Array Declaration public static DataList ConvertColor32(Color32 value) Parameters Type Name Description Color32 value The Color32 to convert Returns Type Description DataList A 4 DataList Byte Array ConvertColor32s(Color32[]) Convert Color32s to a DataList Byte Array Declaration public static DataList ConvertColor32s(Color32[] value) Parameters Type Name Description Color32 [] value The Color32s to convert Returns Type Description DataList A DataList Byte Array ConvertColors(Color[]) Convert Colors to a DataList Byte Array Declaration public static DataList ConvertColors(Color[] value) Parameters Type Name Description Color [] value The Colors to convert Returns Type Description DataList A DataList Byte Array ConvertDataDictionary(DataDictionary) Convert a DataDictionary to a DataList Byte Array Declaration public static DataList ConvertDataDictionary(DataDictionary value) Parameters Type Name Description DataDictionary value The DataDictionary to convert Returns Type Description DataList A single DataList Byte Array ConvertDataList(DataList) Convert a DataList to a DataList Byte Array Declaration public static DataList ConvertDataList(DataList value) Parameters Type Name Description DataList value The DataList to convert Returns Type Description DataList A single DataList Byte Array ConvertDataToken(DataToken) Convert any DataToken type into their byte array equivilent Declaration public static DataList ConvertDataToken(DataToken value) Parameters Type Name Description DataToken value The value to convert Returns Type Description DataList A DataList Byte Array ConvertDateTime(DateTime) Convert a DateTime to a DataList Byte Array Declaration public static DataList ConvertDateTime(DateTime value) Parameters Type Name Description DateTime value The DateTime to convert Returns Type Description DataList A 8 DataList Byte Array ConvertDateTimes(DateTime[]) Convert DateTimes to a DataList Array Declaration public static DataList ConvertDateTimes(DateTime[] value) Parameters Type Name Description DateTime [] value The DateTimes to convert Returns Type Description DataList A DataList containing the individual converted results ConvertDecimal(Decimal) Convert a Decimal floating-point to a DataList Byte Array Declaration public static DataList ConvertDecimal(Decimal value) Parameters Type Name Description Decimal value The Decimal floating-point to convert Returns Type Description DataList A 16 DataList Byte Array ConvertDecimals(Decimal[]) Convert Decimals to a DataList Array Declaration public static DataList ConvertDecimals(Decimal[] value) Parameters Type Name Description Decimal [] value The Decimals to convert Returns Type Description DataList A DataList containing the individual converted results ConvertGUID(Guid) Convert a Guid to a DataList Byte Array Declaration public static DataList ConvertGUID(Guid value) Parameters Type Name Description Guid value The Guid to convert Returns Type Description DataList A 16 DataList Byte Array ConvertGUIDs(Guid[]) Convert Guids to a DataList Array Declaration public static DataList ConvertGUIDs(Guid[] value) Parameters Type Name Description Guid [] value The Guids to convert Returns Type Description DataList A DataList containing the individual converted results ConvertHalf(Single) Convert a half-precision floating-point to a DataList Byte Array Declaration public static DataList ConvertHalf(float value) Parameters Type Name Description Single value The half-precision floating-point to convert Returns Type Description DataList A 2 DataList Byte Array ConvertHalf(Single[]) Convert half floats to a DataList Array Declaration public static DataList ConvertHalf(float[] value) Parameters Type Name Description Single [] value The half floats to convert Returns Type Description DataList A DataList containing the individual converted results ConvertHalfQuaternion(Quaternion) Convert a half Quaternion to a DataList Byte Array Declaration public static DataList ConvertHalfQuaternion(Quaternion value) Parameters Type Name Description Quaternion value The Vector4 to convert Returns Type Description DataList A 8 DataList Byte Array ConvertHalfQuaternion(Quaternion[]) Convert half Quaternions to a DataList Array Declaration public static DataList ConvertHalfQuaternion(Quaternion[] value) Parameters Type Name Description Quaternion [] value The half Quaternions to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertHalfVector2(Vector2) Convert a half Vector2 to a DataList Byte Array Declaration public static DataList ConvertHalfVector2(Vector2 value) Parameters Type Name Description Vector2 value The Vector2 to convert Returns Type Description DataList A 2 DataList Byte Array ConvertHalfVector2s(Vector2[]) Convert half Vector2s to a DataList Array Declaration public static DataList ConvertHalfVector2s(Vector2[] value) Parameters Type Name Description Vector2 [] value The half Vector2s to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertHalfVector3(Vector3) Convert a half Vector3 to a DataList Byte Array Declaration public static DataList ConvertHalfVector3(Vector3 value) Parameters Type Name Description Vector3 value The Vector3 to convert Returns Type Description DataList A 6 DataList Byte Array ConvertHalfVector3(Vector3[]) Convert half Vector3s to a DataList Array Declaration public static DataList ConvertHalfVector3(Vector3[] value) Parameters Type Name Description Vector3 [] value The half Vector3s to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertHalfVector4(Vector4) Convert a half Vector4 to a DataList Byte Array Declaration public static DataList ConvertHalfVector4(Vector4 value) Parameters Type Name Description Vector4 value The Vector4 to convert Returns Type Description DataList A 8 DataList Byte Array ConvertHalfVector4(Vector4[]) Convert half Vector4s to a DataList Array Declaration public static DataList ConvertHalfVector4(Vector4[] value) Parameters Type Name Description Vector4 [] value The half Vector4s to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertInt16(Int16) Convert a Int16 to a DataList Byte Array Declaration public static DataList ConvertInt16(Int16 value) Parameters Type Name Description Int16 value The Int16 to convert Returns Type Description DataList A 2 DataList Byte Array ConvertInt16s(Int16[]) Convert Int16s to a DataList Array Declaration public static DataList ConvertInt16s(Int16[] value) Parameters Type Name Description Int16 [] value The Int16s to convert Returns Type Description DataList A DataList containing the individual converted results ConvertInt32(Int32) Convert an Integer to a DataList Byte Array Declaration public static DataList ConvertInt32(int value) Parameters Type Name Description Int32 value The Integer to convert Returns Type Description DataList A 4 DataList Byte Array ConvertInt32s(Int32[]) Convert ints to a DataList Array Declaration public static DataList ConvertInt32s(int[] value) Parameters Type Name Description Int32 [] value The ints to convert Returns Type Description DataList A DataList containing the individual converted results ConvertInt64(Int64) Convert a 64-bit Integer to a DataList Byte Array Declaration public static DataList ConvertInt64(Int64 value) Parameters Type Name Description Int64 value The Integer to convert Returns Type Description DataList A 8 DataList Byte Array ConvertInt64s(Int64[]) Convert Int64s to a DataList Array Declaration public static DataList ConvertInt64s(Int64[] value) Parameters Type Name Description Int64 [] value The Int64s to convert Returns Type Description DataList A DataList containing the individual converted results ConvertObject(Object) convert any standard/unity type excluding UTF based on typeof into a DataList of bytes Declaration public static DataList ConvertObject(object value) Parameters Type Name Description Object value The value to convert Returns Type Description DataList A DataList Byte Array ConvertQuaternion(Quaternion) Convert a Quaternion to a DataList Byte Array Declaration public static DataList ConvertQuaternion(Quaternion value) Parameters Type Name Description Quaternion value The Vector4 to convert Returns Type Description DataList A 16 DataList Byte Array ConvertQuaternions(Quaternion[]) Convert Quaternions to a DataList Array Declaration public static DataList ConvertQuaternions(Quaternion[] value) Parameters Type Name Description Quaternion [] value The Quaternions to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertSByte(SByte) Convert a SByte to a DataList Byte Array Declaration public static DataList ConvertSByte(sbyte value) Parameters Type Name Description SByte value The SByte to convert Returns Type Description DataList A single DataList Byte Array ConvertSBytes(SByte[]) Convert SBytes to a DataList Array Declaration public static DataList ConvertSBytes(sbyte[] value) Parameters Type Name Description SByte [] value The SBytes to convert Returns Type Description DataList A DataList containing the individual converted results ConvertSingle(Single) Convert a single-precision floating-point into a DataList Byte Array Declaration public static DataList ConvertSingle(float value) Parameters Type Name Description Single value The single-precision floating-point to convert Returns Type Description DataList A 4 DataList Byte Array ConvertSingles(Single[]) Convert floats to a DataList Array Declaration public static DataList ConvertSingles(float[] value) Parameters Type Name Description Single [] value The floats to convert Returns Type Description DataList A DataList containing the individual converted results ConvertTimeSpan(TimeSpan) Convert a TimeSpan to a DataList Byte Array Declaration public static DataList ConvertTimeSpan(TimeSpan value) Parameters Type Name Description TimeSpan value The TimeSpan to convert Returns Type Description DataList A 8 DataList Byte Array ConvertTimeSpans(TimeSpan[]) Convert TimeSpans to a DataList Array Declaration public static DataList ConvertTimeSpans(TimeSpan[] value) Parameters Type Name Description TimeSpan [] value The TimeSpans to convert Returns Type Description DataList A DataList containing the individual converted results ConvertUInt16(UInt16) Convert a UInt16 to a DataList Byte Array Declaration public static DataList ConvertUInt16(UInt16 value) Parameters Type Name Description UInt16 value The UInt16 to convert Returns Type Description DataList A 2 DataList Byte Array ConvertUInt16s(UInt16[]) Convert UInt16s to a DataList Array Declaration public static DataList ConvertUInt16s(UInt16[] value) Parameters Type Name Description UInt16 [] value The UInt16s to convert Returns Type Description DataList A DataList containing the individual converted results ConvertUInt32(UInt32) Convert an Unsigned Integer to a DataList Byte Array Declaration public static DataList ConvertUInt32(uint value) Parameters Type Name Description UInt32 value The Unsigned Integer to convert Returns Type Description DataList A 4 DataList Byte Array ConvertUInt32s(UInt32[]) Convert uints to a DataList Array Declaration public static DataList ConvertUInt32s(uint[] value) Parameters Type Name Description UInt32 [] value The uints to convert Returns Type Description DataList A DataList containing the individual converted results ConvertUInt64(UInt64) Convert a 64-bit Unsigned Integer to a DataList Byte Array Declaration public static DataList ConvertUInt64(UInt64 value) Parameters Type Name Description UInt64 value The Unsigned Integer to convert Returns Type Description DataList A 8 DataList Byte Array ConvertUInt64s(UInt64[]) Convert UInt64 to a DataList Array Declaration public static DataList ConvertUInt64s(UInt64[] value) Parameters Type Name Description UInt64 [] value The UInt64 to convert Returns Type Description DataList A DataList containing the individual converted results ConvertUTF8String(String) Convert a UTF8 string to a DataList Byte Array Declaration public static DataList ConvertUTF8String(string value) Parameters Type Name Description String value The UTF8 String to convert Returns Type Description DataList A DataList Byte Array with the same length as the string or compressed length + 1 ConvertUTF8String(String[]) Convert UTF8 strings to a DataList Array Declaration public static DataList ConvertUTF8String(string[] value) Parameters Type Name Description String [] value The UTF8 strings to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertVector2(Vector2) Convert a Vector2 to a DataList Byte Array Declaration public static DataList ConvertVector2(Vector2 value) Parameters Type Name Description Vector2 value The Vector2 to convert Returns Type Description DataList A 8 DataList Byte Array ConvertVector2s(Vector2[]) Convert Vector2s to a DataList Array Declaration public static DataList ConvertVector2s(Vector2[] value) Parameters Type Name Description Vector2 [] value The Vector2s to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertVector3(Vector3) Convert a Vector3 to a DataList Byte Array Declaration public static DataList ConvertVector3(Vector3 value) Parameters Type Name Description Vector3 value The Vector3 to convert Returns Type Description DataList A 12 DataList Byte Array ConvertVector3s(Vector3[]) Convert Vector3s to a DataList Array Declaration public static DataList ConvertVector3s(Vector3[] value) Parameters Type Name Description Vector3 [] value The Vector3s to convert Returns Type Description DataList A single DataList containing the individual converted results ConvertVector4(Vector4) Convert a Vector4 to a DataList Byte Array Declaration public static DataList ConvertVector4(Vector4 value) Parameters Type Name Description Vector4 value The Vector4 to convert Returns Type Description DataList A 16 DataList Byte Array ConvertVector4s(Vector4[]) Convert Vector4s to a DataList Array Declaration public static DataList ConvertVector4s(Vector4[] value) Parameters Type Name Description Vector4 [] value The Vector4s to convert Returns Type Description DataList A single DataList containing the individual converted results GetPackingType(DataToken) Returns the byte PackingType for a given type Declaration public static PackingType GetPackingType(DataToken value) Parameters Type Name Description DataToken value The data to get the PackingType for Returns Type Description PackingType GetPackingType(Object) Returns the byte PackingType for a given type Declaration public static PackingType GetPackingType(object value) Parameters Type Name Description Object value The data to get the PackingType for Returns Type Description PackingType ReturnDataTokenValueAsObject(DataToken) Returns the value for a DataToken regardless of type as an object Declaration public static object ReturnDataTokenValueAsObject(DataToken value) Parameters Type Name Description DataToken value The DataToken to get the value for Returns Type Description Object object storing the DataToken value"
  },
  "api/Joshf67.ServerConnector.Packing.html": {
    "href": "api/Joshf67.ServerConnector.Packing.html",
    "title": "Namespace Joshf67.ServerConnector.Packing | Server Connector documentation",
    "keywords": "Namespace Joshf67.ServerConnector.Packing Classes ByteConverter This class is a one-way converter to byte arrays, it doesn't not have a way to revert this This class is not optimized with generic objects so use DataTokens due to using typeof search which means we can't use switches because it's not const This is class is a combination of two different methods of converting to make generating server requests easier. https://github.com/Xytabich/UNet/blob/master/UNet/ByteBufferWriter.cs https://github.com/Miner28/NetworkedEventCaller MessagePacker Static helper class that handles packing any messages together to compress the required bits of data Enums PackingType Used to determine what type of packing a DataStructure uses"
  },
  "api/Joshf67.ServerConnector.Packing.MessagePacker.html": {
    "href": "api/Joshf67.ServerConnector.Packing.MessagePacker.html",
    "title": "Class MessagePacker | Server Connector documentation",
    "keywords": "Class MessagePacker Static helper class that handles packing any messages together to compress the required bits of data Inheritance Object MessagePacker Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Joshf67.ServerConnector.Packing Assembly : cs.temp.dll.dll Syntax public static class MessagePacker Methods CompressMessage(DataList, Int32, Int32) Compress any built-in/unity types into a standard structure Declaration public static DataDictionary CompressMessage(DataList message, int bitsToUse = -1, int packingType = 0) Parameters Type Name Description DataList message The message to compress Int32 bitsToUse The bits required from this message, will be calculated if not provided Int32 packingType Determines the method used for packing bits Returns Type Description DataDictionary An DataDictionary containing 4 keys: original_message == The original message, bits_to_use == The bits required for the compress message, message_bytes == The DataList of the bytes of the compressed message packing_type == The PackingType of the compressed message CompressMessage(DataToken, Int32, Int32) Compress any DataToken types into a standard structure Declaration public static DataDictionary CompressMessage(DataToken message, int bitsToUse = -1, int packingType = 0) Parameters Type Name Description DataToken message The DataToken to compress Int32 bitsToUse The bits required from this message, will be calculated if not provided Int32 packingType Determines the method used for packing bits Returns Type Description DataDictionary An DataDictionary containing 4 keys: original_message == The original message, bits_to_use == The bits required for the compress message, message_bytes == The DataList of the bytes of the compressed message packing_type == The PackingType of the compressed message CompressMessage(Object, Int32, Int32) Compress any built-in/unity types into a standard structure Declaration public static DataDictionary CompressMessage(object message, int bitsToUse = -1, int packingType = 0) Parameters Type Name Description Object message The message to compress Int32 bitsToUse The bits required from this message, will be calculated if not provided Int32 packingType Determines the method used for packing bits Returns Type Description DataDictionary An DataDictionary containing 4 keys: original_message == The original message, bits_to_use == The bits required for the compress message, message_bytes == The DataList of the bytes of the compressed message packing_type == The PackingType of the compressed message IsCompressedMessage(DataDictionary, Boolean) Compares if a DataList parameter is in the format of a compressed message Declaration public static bool IsCompressedMessage(DataDictionary message, bool logAsWarning = false) Parameters Type Name Description DataDictionary message The message to check Boolean logAsWarning Determines if the message requires warning mode and will be logged as such Returns Type Description Boolean Boolean determining the structure type IsCompressedMessage(Object, Boolean) Compares if an object parameter is in the format of a compressed message Declaration public static bool IsCompressedMessage(object message, bool logAsWarning = false) Parameters Type Name Description Object message The message to check Boolean logAsWarning Determines if the message requires warning mode and will be logged as such Returns Type Description Boolean Boolean determining the structure type PackMessageBytesToURL(DataList, ConnectorMessageType, Byte, Byte) Pack message bytes into a useable url Declaration public static DataList PackMessageBytesToURL(DataList messages, ConnectorMessageType messageType, byte packedMessageBitSize, byte messageTypeSize) Parameters Type Name Description DataList messages The messages to pack ConnectorMessageType messageType The type of message that is being sent Byte packedMessageBitSize The total size of a packed chunk/message Byte messageTypeSize The total bits count to be used for the message type Returns Type Description DataList A DataList containing all the packed/converted URLs PackMessageBytesToURL(DataToken, ConnectorMessageType, Byte, Byte) Pack a single DataToken message into a useable url Declaration public static DataList PackMessageBytesToURL(DataToken message, ConnectorMessageType messageType, byte packedMessageBitSize, byte messageTypeSize) Parameters Type Name Description DataToken message The DataToken to pack ConnectorMessageType messageType The type of message that is being sent Byte packedMessageBitSize The total size of a packed chunk/message Byte messageTypeSize The total bits count to be used for the message type Returns Type Description DataList A DataList containing all the packed/converted URLs PackMessageBytesToURL(Object, ConnectorMessageType, Byte, Byte) Tries to pack an object message into a useable url Declaration public static DataList PackMessageBytesToURL(object message, ConnectorMessageType messageType, byte packedMessageBitSize, byte messageTypeSize) Parameters Type Name Description Object message The object to pack ConnectorMessageType messageType The type of message that is being sent Byte packedMessageBitSize The total size of a packed chunk/message Byte messageTypeSize The total bits count to be used for the message type Returns Type Description DataList A DataList containing all the packed/converted URLs"
  },
  "api/Joshf67.ServerConnector.Packing.PackingType.html": {
    "href": "api/Joshf67.ServerConnector.Packing.PackingType.html",
    "title": "Enum PackingType | Server Connector documentation",
    "keywords": "Enum PackingType Used to determine what type of packing a DataStructure uses Namespace : Joshf67.ServerConnector.Packing Assembly : cs.temp.dll.dll Syntax public enum PackingType Fields Name Description BigEndian Indicates that the data uses Big Endian for its DataStructure LittleEndian Indicates that the data uses Little Endian for its DataStructure None Used in functions where the PackingType should be inferred from the type Sequential Indicates that the Endian of this DataStructure, doesn't matter and should be treated as sequential when packing"
  },
  "api/Joshf67.ServerConnector.Server.html": {
    "href": "api/Joshf67.ServerConnector.Server.html",
    "title": "Namespace Joshf67.ServerConnector.Server | Server Connector documentation",
    "keywords": "Namespace Joshf67.ServerConnector.Server Classes ServerResponse Base abstract class to allow generic server response reading Enums ServerResponseType Used to determine the response type from a server"
  },
  "api/Joshf67.ServerConnector.Server.ServerResponse.html": {
    "href": "api/Joshf67.ServerConnector.Server.ServerResponse.html",
    "title": "Class ServerResponse | Server Connector documentation",
    "keywords": "Class ServerResponse Base abstract class to allow generic server response reading Inheritance Object ServerResponse Namespace : Joshf67.ServerConnector.Server Assembly : cs.temp.dll.dll Syntax public abstract class ServerResponse : UdonSharpBehaviour Properties Content Public getter for the content of the response Declaration public DataToken Content { get; } Property Value Type Description DataToken Response Public getter for the full message recieved from a server Declaration public DataToken Response { get; } Property Value Type Description DataToken Type Public getter for the type of response Declaration public ServerResponseType Type { get; } Property Value Type Description ServerResponseType Methods GetMessageContent(DataDictionary) Parses a JSON DataDictionary and finds the Response content Declaration public static DataToken GetMessageContent(DataDictionary response) Parameters Type Name Description DataDictionary response The JSON DataDictionary to parse Returns Type Description DataToken The content of a response or an error if invalid GetMessageContent(String) Parses a JSON String and finds the Response content Declaration public static DataToken GetMessageContent(string response) Parameters Type Name Description String response The JSON String to parse Returns Type Description DataToken The content of a response or an error if invalid GetMessageType(DataDictionary) Parses a JSON DataDictionary and finds the Response type Declaration public static ServerResponseType GetMessageType(DataDictionary response) Parameters Type Name Description DataDictionary response The JSON DataDictionary to parse Returns Type Description ServerResponseType The response type of the message GetMessageType(String) Parses a JSON String and finds the Response type Declaration public static ServerResponseType GetMessageType(string response) Parameters Type Name Description String response The JSON String to parse Returns Type Description ServerResponseType The response type of the message HandleResponse(DataDictionary, out DataToken) Handles the parsed message Declaration protected abstract bool HandleResponse(DataDictionary response, out DataToken HandleResult) Parameters Type Name Description DataDictionary response The JSON DataDictionary to be handled DataToken HandleResult The result of the ServerRespons handler Returns Type Description Boolean Boolean if the response was parsed properly Parse(String, out DataToken) Parses a JSON String and handle the message Declaration public bool Parse(string message, out DataToken HandleResult) Parameters Type Name Description String message The JSON String to parse DataToken HandleResult The result of the ServerRespons handler Returns Type Description Boolean Boolean if the response was handled or not ParseWithoutHandling(String) Parses a JSON String and does not try to handle it, useful for saving logic for later Declaration public bool ParseWithoutHandling(string message) Parameters Type Name Description String message The JSON String to parse Returns Type Description Boolean Boolean if the response was handled or not ParseWithoutResult(String) Parses a JSON String and handle the response but ignore the result Declaration public bool ParseWithoutResult(string message) Parameters Type Name Description String message The JSON String to parse Returns Type Description Boolean Boolean if the response was handled or not"
  },
  "api/Joshf67.ServerConnector.Server.ServerResponseType.html": {
    "href": "api/Joshf67.ServerConnector.Server.ServerResponseType.html",
    "title": "Enum ServerResponseType | Server Connector documentation",
    "keywords": "Enum ServerResponseType Used to determine the response type from a server Namespace : Joshf67.ServerConnector.Server Assembly : cs.temp.dll.dll Syntax public enum ServerResponseType Fields Name Description Account_Creation_Complete The server was able to create a user for the built login hash Added_Item The server has updated a user's inventory items to add the new items Failed The server failed to recieve and handle the message for some reason Failed_To_Parse The server was unable to parse the message Item_Updated The server has recieved an update to the item related message Login_Complete The server managed to find a user for the built login hash Login_Failed The server failed to find a user for the built login hash Login_Updated The login hash was updated None The server did not respond with a type Removed_Item The server has updated a user's inventory items to remove the requested items Server_Error The server encountered an error with the request Succeeded The server succeeded in recieving and handling the message Type_Fail The server was expecting a message with a different type Unexpected_Request The server was not expecting a response User_Not_Logged_In The user is not currently logged in when making a request"
  },
  "base-server-api/ConnectionHandler.html": {
    "href": "base-server-api/ConnectionHandler.html",
    "title": "Class ConnectionHandler | Server Connector documentation",
    "keywords": "Class ConnectionHandler Class that handles all of the current active users on the server Constructors ConnectionHandler() Declaration new ConnectionHandler() Functions AddUser(ipHash) Adds a user to the current users list Declaration function AddUser(ipHash) Parameters Type Name Description string ipHash The hashed version of the user's IP Returns Type Description the newly created UserConnectionData GetUser(ipHash) Gets a user from the current users lists Declaration function GetUser(ipHash) Parameters Type Name Description string ipHash The hashed version of the user's IP Returns Type Description the UserConnectionData associated with the user RemoveUser(ipHash) Removes a user from the users list Declaration function RemoveUser(ipHash) Parameters Type Name Description string ipHash The hashed version of the user's IP Returns Type Description If the user was removed GetConnectedUsers() Returns all of the currently connected users Declaration function GetConnectedUsers() Returns Type Description All the connected users's UserConnectionData GetConnectedUsersCount() Returns a count of all of the currently connected users Declaration function GetConnectedUsersCount() Returns Type Description Count of all the connected users's UserConnectionData PruneInactiveUsers() Removes any users for the user list if they have been inactive for too long Declaration function PruneInactiveUsers()"
  },
  "base-server-api/index.html": {
    "href": "base-server-api/index.html",
    "title": "Package base-nodejs-server | Server Connector documentation",
    "keywords": "Package base-nodejs-server Classes ServerConnector Class that handles the entry point for a connection from VRC to the Server MessageHandler Class that handles the entry point for a message from VRC to the Server MessageBuilder Stores data for a message's generation exports Constructs a class to store all user connection data exports Stores any user related data ConnectionHandler Class that handles all of the current active users on the server"
  },
  "base-server-api/MessageBuilder.html": {
    "href": "base-server-api/MessageBuilder.html",
    "title": "Class MessageBuilder | Server Connector documentation",
    "keywords": "Class MessageBuilder Stores data for a message's generation Constructors MessageBuilder() Declaration new MessageBuilder() Functions AddMessageBytes(message) Handles building up the message Declaration function AddMessageBytes(message) Parameters Type Name Description base-nodejs-server.Array.<byte> message the character bytes to add to the message"
  },
  "base-server-api/MessageHandler.html": {
    "href": "base-server-api/MessageHandler.html",
    "title": "Class MessageHandler | Server Connector documentation",
    "keywords": "Class MessageHandler Class that handles the entry point for a message from VRC to the Server Constructors MessageHandler() Declaration new MessageHandler() Functions HandleMessage(user, req, res) Entry for server handling message requests Declaration function HandleMessage(user, req, res) Parameters Type Name Description base-nodejs-server.UserConnectionData user The user data for this connected user base-nodejs-server.* req The current express request base-nodejs-server.* res The express response"
  },
  "base-server-api/module.exports#module.exports.html": {
    "href": "base-server-api/module.exports#module.exports.html",
    "title": "Class exports | Server Connector documentation",
    "keywords": "Class exports Constructs a class to store all user connection data Constructors exports(ipHash) Constructs a class to store all user connection data Declaration new exports(ipHash) Parameters Type Name Description string ipHash The IP of the user hashed to anonymize it"
  },
  "base-server-api/module.exports.html": {
    "href": "base-server-api/module.exports.html",
    "title": "Class exports | Server Connector documentation",
    "keywords": "Class exports Stores any user related data Constructors exports() Declaration new exports() Members Message Binary string Declaration Message Returns Type Description Array.<String> Functions HandleResponse(user, response, res) Handles sending off a response to a user Declaration function HandleResponse(user, response, res) Parameters Type Name Description base-nodejs-server.UserConnectionData user The user to send the response to base-nodejs-server.ResponseData response The response content base-nodejs-server.* res The express response SucceedResponse(user, res) Responds to a user's request with a static succeed value Declaration function SucceedResponse(user, res) Parameters Type Name Description base-nodejs-server.UserConnectionData user The user to send the response to base-nodejs-server.* res FailResponse(user, res) Responds to a user's request with a static failed value Declaration function FailResponse(user, res) Parameters Type Name Description base-nodejs-server.UserConnectionData user The user to send the response to base-nodejs-server.* res ResendResponse(user, res) Responds to a user's request with a static resend value Declaration function ResendResponse(user, res) Parameters Type Name Description base-nodejs-server.UserConnectionData user The user to send the response to base-nodejs-server.* res"
  },
  "base-server-api/ServerConnector.html": {
    "href": "base-server-api/ServerConnector.html",
    "title": "Class ServerConnector | Server Connector documentation",
    "keywords": "Class ServerConnector Class that handles the entry point for a connection from VRC to the Server Constructors ServerConnector() Declaration new ServerConnector()"
  },
  "database-server-api/ConnectionHandler.html": {
    "href": "database-server-api/ConnectionHandler.html",
    "title": "Class ConnectionHandler | Server Connector documentation",
    "keywords": "Class ConnectionHandler Class that handles all of the current active users on the server Constructors ConnectionHandler() Declaration new ConnectionHandler() Functions AddUser(ipHash) Adds a user to the current users list Declaration function AddUser(ipHash) Parameters Type Name Description string ipHash The hashed version of the user's IP Returns Type Description the newly created UserConnectionData GetUser(ipHash) Gets a user from the current users lists Declaration function GetUser(ipHash) Parameters Type Name Description string ipHash The hashed version of the user's IP Returns Type Description the UserConnectionData associated with the user RemoveUser(ipHash) Removes a user from the users list Declaration function RemoveUser(ipHash) Parameters Type Name Description string ipHash The hashed version of the user's IP Returns Type Description If the user was removed GetConnectedUsers() Returns all of the currently connected users Declaration function GetConnectedUsers() Returns Type Description All the connected users's UserConnectionData GetConnectedUsersCount() Returns a count of all of the currently connected users Declaration function GetConnectedUsersCount() Returns Type Description Count of all the connected users's UserConnectionData PruneInactiveUsers() Removes any users for the user list if they have been inactive for too long Declaration function PruneInactiveUsers()"
  },
  "database-server-api/index.html": {
    "href": "database-server-api/index.html",
    "title": "Package database-nodejs-server | Server Connector documentation",
    "keywords": "Package database-nodejs-server Classes ServerConnector Class that handles the entry point for a connection from VRC to the Server MessageHandler Class that handles the entry point for a message from VRC to the Server MessageBuilder Stores data for a message's generation exports Constructs a class to store all user connection data exports Stores any user related data ConnectionHandler Class that handles all of the current active users on the server"
  },
  "database-server-api/MessageBuilder.html": {
    "href": "database-server-api/MessageBuilder.html",
    "title": "Class MessageBuilder | Server Connector documentation",
    "keywords": "Class MessageBuilder Stores data for a message's generation Constructors MessageBuilder() Declaration new MessageBuilder() Functions AddMessageBytes(message) Handles building up the message Declaration function AddMessageBytes(message) Parameters Type Name Description database-nodejs-server.Array.<byte> message the character bytes to add to the message"
  },
  "database-server-api/MessageHandler.html": {
    "href": "database-server-api/MessageHandler.html",
    "title": "Class MessageHandler | Server Connector documentation",
    "keywords": "Class MessageHandler Class that handles the entry point for a message from VRC to the Server Constructors MessageHandler() Declaration new MessageHandler() Functions HandleMessage(user, req, res) Entry for server handling message requests Declaration function HandleMessage(user, req, res) Parameters Type Name Description database-nodejs-server.UserConnectionData user The user data for this connected user database-nodejs-server.* req The current express request database-nodejs-server.* res The express response"
  },
  "database-server-api/module.exports#module.exports.html": {
    "href": "database-server-api/module.exports#module.exports.html",
    "title": "Class exports | Server Connector documentation",
    "keywords": "Class exports Constructs a class to store all user connection data Constructors exports(ipHash) Constructs a class to store all user connection data Declaration new exports(ipHash) Parameters Type Name Description string ipHash The IP of the user hashed to anonymize it"
  },
  "database-server-api/module.exports.html": {
    "href": "database-server-api/module.exports.html",
    "title": "Class exports | Server Connector documentation",
    "keywords": "Class exports Stores any user related data Constructors exports() Declaration new exports() Members databaseData Declaration databaseData Returns Type Description Document Message Binary string Declaration Message Returns Type Description Array.<String> Functions HandleResponse(user, response, res) Handles sending off a response to a user Declaration function HandleResponse(user, response, res) Parameters Type Name Description database-nodejs-server.UserConnectionData user The user to send the response to database-nodejs-server.ResponseData response The response content database-nodejs-server.* res The express response SucceedResponse(user, res) Responds to a user's request with a static succeed value Declaration function SucceedResponse(user, res) Parameters Type Name Description database-nodejs-server.UserConnectionData user The user to send the response to database-nodejs-server.* res FailResponse(user, res) Responds to a user's request with a static failed value Declaration function FailResponse(user, res) Parameters Type Name Description database-nodejs-server.UserConnectionData user The user to send the response to database-nodejs-server.* res ResendResponse(user, res) Responds to a user's request with a static resend value Declaration function ResendResponse(user, res) Parameters Type Name Description database-nodejs-server.UserConnectionData user The user to send the response to database-nodejs-server.* res"
  },
  "database-server-api/ServerConnector.html": {
    "href": "database-server-api/ServerConnector.html",
    "title": "Class ServerConnector | Server Connector documentation",
    "keywords": "Class ServerConnector Class that handles the entry point for a connection from VRC to the Server Constructors ServerConnector() Declaration new ServerConnector()"
  },
  "example/Introduction.html": {
    "href": "example/Introduction.html",
    "title": "MongoDB Connector Example | Server Connector documentation",
    "keywords": "MongoDB Connector Example In this example I will walk through the steps I took to make a connector between VRC and a MongoDB database, this will not go super into depth on how every line of code works, but the source code is provided in the github repository if you wish to look at it. Warning: There is a lot of code below. Once you get the hang of it, it shouldn't be too difficult, however, it has a steep learning curve due to the compexity of this API so... good luck reading it. Requirements Store client data on an externally hosted MongoDB and interact with that from within VRC. Allow a client to send a login/password to the server which autheticates them with a unique account. Allow a client to update a list of items that are stored inside that database and have it display for them. Step 0. Setting up the base project I started by cloning the repository and setting up the inital server settings. I then create a new VRC Unity project and installed the Server Connector Package. Step 1. Setting up the MongoDB instance There are a bunch of free MongoDB hosting sites out there, however, I have decided to go with MongoDB's own free hosting, here's a link to their own tutorial on how to set things up. For this example I am going to be using certification authentication so I need to generate one that allows me access to the database: I stored the generated certificate inside it's own folder. I setup some properties on my .env file to allow me to access this easier later on, I also knew that I wanted to make the client \"log\" into the database by requesting the data for a specific hash: see Example server settings for more details PORT=33646 MESSAGE_TYPE_BITS=4 MESSAGE_BITS_LENGTH=21 //This was added during this step DATABASE_URL=\"mongodb+srv://xxxx.xxxx.mongodb.net/RPGDatabase\" DATABASE_NAME=\"RPGDatabase\" DATABASE_CONNECTION_TIMEOUT=2000 DATABASE_USER_CERT=\"Mongodb/mongo.pem\" LOGIN_HASH_CHARACTERS=9 //This was added during this step PRUNE_INACTIVE_TIME_MINUTES=30 DEVELOPMENT_MODE=true Step 2. Adding a way to connect to the database in the NodeJS server The first thing to do is to get out NodeJS server connected to the MongoDB instance: In the following code you can see a \"UserModel\" this is just a mongoose schema that lays out the structure of the database, for this example it's multiple schema's layered into each other to produce this structure: User: { loginHash: String Inventory: { Currency: Number Items: [ itemID: Number, ... ] } } const mongoose = require(\"mongoose\"); const path = require(\"path\"); const logger = require(\"../logger\"); //Remove excess data not needed from the database mongoose.plugin((schema) => { schema.options.toJSON = { virtuals: true, versionKey: false, transform(doc, ret) { delete ret._id; delete ret.id; } }; }); const UserModel = require(\"./database-schema/user/user-model\"); class DatabaseHandler { client; constructor() { Connect( process.env.DATABASE_URL, path.join(__dirname, \"../../../\", process.env.DATABASE_USER_CERT) ).then( function (client) { this.client = client; }.bind(this) ); // If the Node process ends, close the Mongoose connection process.on(\"SIGINT\", function () { mongoose.connection.close(function () { logger.log(\"Mongoose disconnected on app termination\"); process.exit(0); }); }); } /** * Request user from database if the hash exists, if not create it * @param {string} userLoginHash - The user's login * @returns {Promise} The user's database entry */ async addUserData(userLoginHash) { return new Promise((resolve, reject) => { //Try to get the data before adding it this.getUserData(userLoginHash) .then((user) => { resolve(user); }) .catch((error) => { //Generate new user data and save it to the database let newUser = new UserModel({ loginHash: userLoginHash }); newUser.save().finally(() => { //Get that saved data from the database //Can probably be replaced with a blank response this.getUserData(userLoginHash) .then((user) => { resolve(user); }) .catch((error) => { //If the data doesn't exist, something went wrong logger.error(error); reject(error); }); }); }); }); } /** * Request user from database if the hash exists * @param {string} userLoginHash - The user's login * @returns {Promise} The user's database entry */ async getUserData(userLoginHash) { return new Promise((resolve, reject) => { UserModel.find({ loginHash: userLoginHash }) .then((value) => { if (value.length == 0) { reject(`Unable to find user: ${userLoginHash}`); } else { resolve(value); } }) .catch((error) => { reject(\"Unable to find user: \" + error); }); }); } } /** * Handles connecting to database * @param {string} uri - The location of the database * @param {string} cert - The certification to connect to the database * @returns {Promise} - Returns a promise for the connection */ function Connect(uri, cert) { return new Promise((resolve) => { logger.log(\"Initiating connection to database\"); mongoose .connect(uri, { ssl: true, sslValidate: false, sslKey: cert, sslCert: cert, authMechanism: \"MONGODB-X509\", }) .then((client) => { logger.log(\"Connected to database successfully\"); resolve(client); }) .catch((error) => { logger.error(error); }); }); } This allows class tries to connect to a MongoDB instance by using mongoose which is a set of wrapper functions around the MongoDB API to make it easier to use, the connect function was a little complicated for me as I have never done any of this before so, it took me a while to figure out how to connect to the MongoDB with the certification file we downloaded above. Step 3. Messaging the NodeJS server from within VRC As I mentioned before, I decided that I would make the client log into a database using a unique 9 character hash, the first thing to do was to start getting the VRC client to message the server with the hash. The first thing I implemented on the client was a way to convert a user's input into a 9 character hash, I found a hashing script that Gorialis made called UdonHashLib which I am using to convert a string into a SHA512 hash: The following C# code is inside a class that extends the ServerConnector class. protected UdonHashLib hasher; public string ConvertTextToHash(string text) { return hasher.SHA512_UTF8(text); } public string ConvertSHA256ToMessage(string hash) { if (hash.Length != 128) return \"\"; return new string(new char[] { hash[0], hash[15], hash[31], hash[47], hash[63], hash[79], hash[95], hash[111], hash[127] }); } The next step was to setup the UI for a user to execute the login/account creation login public void Login() { AddMessagesToBuffer(MessagePacker.PackMessageBytesToURL(GenerateLoginHashBytes(), ConnectorMessageType.Login, packingMessageBitSize, messageTypeSize)); } public void CreateAccount() { AddMessagesToBuffer(MessagePacker.PackMessageBytesToURL(GenerateLoginHashBytes(), ConnectorMessageType.AccountCreation, packingMessageBitSize, messageTypeSize)); } That is all that is required on the client side to send off the required requests to the server, next was to handle everything on the NodeJS server. Step 4. Handling VRC client messages on the NodeJS server The first step was to implement the type on the main message-handler section: //Switch statement that handles all different types of messages switch (unpackedMessage.Type) { case MessageTypes.Login: return LoginHandler.HandleInitialMessage( user, res, unpackedMessage.Message ); break; case MessageTypes.AccountCreation: return LoginHandler.HandleInitialMessage( user, res, unpackedMessage.Message, true ); break; ... } next is to implement a builder to accept the above requests and awaits for the 9 login hash characters until continuing: const logger = require(\"../../../logger\"); const DatabaseHandler = require(\"../../../database-handler/database-handler\"); const UserConnectionData = require(\"../../../connection-handler/user-connection-data\"); const URLMessage = require(\"../../url-message\"); const ResponseHandler = require(\"../../../response-handler/response-handler\"); const ResponseData = require(\"../../../response-handler/response-data\"); const { ResponseTypes } = require(\"../../../response-handler/response-types\"); const MessageBuilder = require(\"../../message-builder\"); const { MessageLength } = require(\"../../message-length\"); class LoginHandler { /** * Handles the first login related message and sets up a user's expecting data * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {URLMessage} message - The parsed message from the connection * @param {bool} creatingAccount - Controls if the login hash will be used to create a new user */ static HandleInitialMessage(user, res, message, creatingAccount = false) { //Build the message listener data user.expectingDataState = new MessageBuilder( LoginHandler.HandleMessageUpdate, LoginHandler.HandleMessageFinish, MessageLength.Login, { creatingAccount: creatingAccount } ); //Setup the message listener and then send the remaining message bits into it user.expectingDataCallback = user.expectingDataState.AddMessageBytes; user.expectingDataCallback(user, res, message); } /** * Handles login related messages that add to the login hash * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {*} bitsRemaining - The bits remaining until the message is complete */ static HandleMessageUpdate(user, res, bitsRemaining) { //If the user is already logged in, return the correct log in if (user.loginHash != null) { return LoginHandler.HandleLogin(user, res); } //Continue listening to data ResponseHandler.HandleResponse( user, res, new ResponseData( ResponseTypes.Login_Updated, `Login Hash Part Recieved, Awaiting ${bitsRemaining} bits` ) ); } /** * Handles finishing up login related messages to build up a user login hash * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {string[]} fullMessageBits - The message in a string binary array * @param {*} options - The options passed to the message builder on creation */ static HandleMessageFinish(user, res, fullMessageBits, options) { let loginBytes = []; for (let i = 0; i < MessageLength.Login; i += 8) { loginBytes.push(parseInt(fullMessageBits.slice(i, i + 8).join(\"\"), 2)); } const loginHash = new TextDecoder().decode(new Uint8Array(loginBytes)); logger.log(loginHash); //Handle finishing up userHashData message user.expectingDataCallback = null; user.expectingDataState = null; user.userHash = loginHash; if (options?.creatingAccount) return LoginHandler.HandleAccountCreation(user, res); return LoginHandler.HandleLogin(user, res); } This Initial message handler sets up all of the parameters of the message builder class to wait for 9 login character's worth of bytes before continuing onto either loggin in or creating an account depending on the message type: /** * Sends off a request to the database to get a user and responds with the result * @param {UserConnectionData} user - The user data that contains all required info * @param {*} res - The express response for the user */ static HandleLogin(user, res) { DatabaseHandler.getUserData(user.userHash) .then((userData) => { user.databaseData = userData[0]; return ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Login_Complete, userData[0]) ); }) .catch((error) => { //Fail due to account not existing or another error console.error(error); if (error.indexOf(\"Unable to find user\") != -1) return ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Login_Failed, \"User does not exist\") ); ResponseHandler.FailResponse(user, res); }); } /** * Sends off a request to the database to generate a user and responds with the result * @param {UserConnectionData} user - The user data that contains all required info * @param {*} res - The express response for the user */ static HandleAccountCreation(user, res) { DatabaseHandler.addUserData(user.userHash) .then((userData) => { user.databaseData = userData[0]; ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Account_Creation_Complete, userData[0]) ); }) .catch((error) => { //Fail due to account not being able to be created console.error(error); ResponseHandler.FailResponse(user, res); }); } } This is everything we need for the first and second requirement, next is to start implementing a way to allow a client to modify their own items Step 5. Implementing VRC UI to modify items This one is quite simple, I decided to go with 2 input fields that take a number and then request build a server response based on a button click: /// <summary> /// Queue up an add item message to the server and attempt to add it /// </summary> public void AddItem() { if (AddItemField.text == \"\") return; //Only allow 8 bit indices for the item to add byte itemId = (byte)(int.Parse(AddItemField.text) & 0xFF); if (itemId < 0 || itemId > 255) return; //Set up the options to send to the server's add item function //1st bit = adding, next 7 bits = The amount of items to add, next 8 bits... = itemId AddMessagesToBuffer( MessagePacker.PackMessageBytesToURL( new object[] { MessagePacker.CompressMessage(true, 1), MessagePacker.CompressMessage((byte)1, 7), MessagePacker.CompressMessage(itemId) }, ConnectorMessageType.ModifyItem, packingMessageBitSize, messageTypeSize ) ); } /// <summary> /// Queue up a remove item message to the server and attempt to remove it /// </summary> public void RemoveItem() { if (RemoveItemField.text == \"\") return; //Only allow 7 bit indices for removing byte itemIndex = (byte)(int.Parse(RemoveItemField.text) & 0xFF); if (itemIndex < 0 || itemIndex > 255) return; DataList packingParams = new DataList(); packingParams.Add(MessagePacker.CompressMessage(false, 1)); packingParams.Add(MessagePacker.CompressMessage((byte)1, 7)); packingParams.Add(MessagePacker.CompressMessage(itemIndex)); //Set up the options to send to the server's add item function //1st bit = removing, next 7 bits = The amount of indices to remove, next 8 bits... = index to remove AddMessagesToBuffer( MessagePacker.PackMessageBytesToURL( packingParams, ConnectorMessageType.ModifyItem, packingMessageBitSize, messageTypeSize ) ); } Because I am trying to do both adding/removing by only using a single type I needed to package my messages a little bit more complicated, I started off by using the first bit of a message to indicate if it was adding or removing, then the next 7 bits to indicate how many actions the server should wait for when building up the message. Finally I pack the item indices/ids as bytes one after another, this will be parsed using the action count in the 7 bits. Step 6. Modifying a client's items The first part is to add another type to our main message-handler logic: case MessageTypes.ModifyItem: return ItemHandler.HandleInitialMessage( user, res, unpackedMessage.Message ); break; For these sets of methods I have decided that I want to try and only use 1 type for adding and removing, this means that the initial message building will be slightly more complicated than the login one: const logger = require(\"../../../logger\"); const UserConnectionData = require(\"../../../connection-handler/user-connection-data\"); const ResponseHandler = require(\"../../../response-handler/response-handler\"); const ResponseData = require(\"../../../response-handler/response-data\"); const { ResponseTypes } = require(\"../../../response-handler/response-types\"); const { MessageLength } = require(\"../../message-length\"); const MessageBuilder = require(\"../../message-builder\"); const { ItemSchemaJS, } = require(\"../../../database-handler/database-schema/inventory/item-schema\"); class ItemHandler { /** * Handles the first item related message and sets up a user's expecting data * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {String[]} message - The parsed message from the connection */ static HandleInitialMessage(user, res, message) { //First bit of a Item message is use to determine if it should be adding or removing let addingItems = message[0] == \"1\"; //The next 7 bits are used to store how many items/indices are in the message let items = parseInt(message.slice(1, 8).join(\"\"), 2); //Build the message listener data user.expectingDataState = new MessageBuilder( ItemHandler.HandleMessageUpdate, ItemHandler.HandleMessageFinish, addingItems == true ? MessageLength.Item * items : MessageLength.ItemIndex * items, { addingItems: addingItems, items: items, } ); //Setup the message listener and then send the remaining message bits into it user.expectingDataCallback = user.expectingDataState.AddMessageBytes; user.expectingDataCallback(user, res, message.slice(8)); } /** * Handles item related messages * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {*} bitsRemaining - The bits remaining until the message is complete */ static HandleMessageUpdate(user, res, bitsRemaining) { //Continue listening to data ResponseHandler.HandleResponse( user, res, new ResponseData( ResponseTypes.Item_Updated, `Item message Recieved, Awaiting ${bitsRemaining} bits` ) ); } /** * Handles finishing up item messages * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {string[]} fullMessageBits - The message in a string binary array * @param {*} options - The options passed to the message builder on creation */ static HandleMessageFinish(user, res, fullMessageBits, options) { if (options.addingItems) { let items = []; //Build up all of the items to add from the message bits for (let i = 0; i < options.items * MessageLength.Item; i += MessageLength.Item) { items.push( new ItemSchemaJS( parseInt(fullMessageBits.slice(i, i + MessageLength.Item).join(\"\"), 2) ) ); } logger.log(items); ItemHandler.AddItems(user, res, items); } else { let indices = []; //Build up all of the indices from the message bits for (let i = 0; i < options.items * MessageLength.Item; i += MessageLength.Item) { indices.push( parseInt(fullMessageBits.slice(i, i + MessageLength.ItemIndex).join(\"\"), 2) ); } logger.log(indices); ItemHandler.RemoveItems(user, res, indices); } } ... This time I decided to pass a few encoded messages inside the initial message, the first part is to tell the server what type of message this adding or removing, I do this by using the first bit in the message, I then follow that up with the next 7 bits being for the amount of actions this message should be expecting (In this example it's how many actions to remove/add will follow), after this I plan to send a single byte per action (0-255). The message-builder class has a parameter for any options that you wish to pass to the final message function, in this case we store how many actions are in the message and wether we are removing or adding items. After the message has been fully built out, we can call a function to either add or remove: /** * Handles item addition * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {ItemSchemaJS[]} items - The items to be added */ static AddItems(user, res, items) { //Update the local inventory items user.databaseData.Inventory.Items = user.databaseData?.Inventory?.Items?.concat?.(items); //Fire off a request to save the data into the database user.databaseData .save() .then((saved) => { //If it saved then respond with succeeded message ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Added_item, items) ); }) .catch((error) => { logger.warn(error); ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Server_Error) ); }); } /** * Handles item removal * @param {UserConnectionData} user - The user this message is for * @param {*} res * @param {int[]} indices - The item indexes to be removed */ static RemoveItems(user, res, indices) { /* sort all of the indices by largets first so that when we remove any items it wont affect the rest of the indices position and remove any indices that are above the actual inventory item count */ indices = indices.sort((a, b) => { return a - b; }).filter( (index) => index < (user.databaseData?.Inventory?.Items.length ?? 0) ); //If there are no indices left then we don't need to message the database, so respond if (indices.length == 0) { return ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Removed_item, indices) ); } //Remove all of the incides indices.forEach((index) => { user.databaseData?.Inventory?.Items?.splice?.(index, 1); }); //Fire off a request to save the data into the database user.databaseData .save() .then((saved) => { //If it saved then respond with succeeded message ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Removed_item, indices) ); }) .catch((error) => { logger.warn(error); ResponseHandler.HandleResponse( user, res, new ResponseData(ResponseTypes.Server_Error) ); }); } } and that's it, implementing the adding/removing of items was a lot easier to do due to having the message building all fleshed out in the login section Step 7. Implementing VRC UI Display for all of the above code In order to easily display that the client's inputs are actually working, I decided to display them in text for the client to see. The first thing I need for this, is to create a ServerResponse to handle the response from the NodeJS server inside VRC, this will be a very simple response that I will hardcode a response message for based on what the server should respond with: /// <summary> /// Example response to show how to handle server responses /// </summary> public class ExampleServerResponse : ServerResponse { /// <summary> /// Handles the parsed message /// </summary> /// <param name=\"response\"> The JSON DataDictionary to be handled </param> /// <param name=\"HandleResult\"> The result of the ServerRespons handler </param> /// <returns> Boolean if the response was parsed properly </returns> override protected bool HandleResponse(DataDictionary response, out DataToken HandleResult) { HandleResult = new DataToken(DataError.None); bool messageWasParsedSucessfully = false; if (Type == ServerResponseType.Login_Failed) { if (DevelopmentManager.IsServerResponseEnabled(DevelopmentMode.Basic)) Debug.Log(\"ServerExampleResponse is handling a login failed type\"); //The login has failed for some reason, so we need to display this to the user HandleResult = new DataToken(\"Login credentials are invalid, please try again or create an account\"); } else if (Type == ServerResponseType.Login_Updated) { if (DevelopmentManager.IsServerResponseEnabled(DevelopmentMode.Basic)) Debug.Log(\"ServerExampleResponse is handling a login update type\"); //Server sends message with a string response so this will display the bits remaining until login completion messageWasParsedSucessfully = response.TryGetValue(\"response\", TokenType.String, out HandleResult); } else if (Type == ServerResponseType.Login_Complete) { if (DevelopmentManager.IsServerResponseEnabled(DevelopmentMode.Basic)) Debug.Log(\"ServerExampleResponse is handling a login complete type\"); messageWasParsedSucessfully = response.TryGetValue(\"response\", TokenType.DataDictionary, out HandleResult); } else if (Type == ServerResponseType.Account_Creation_Complete) { if (DevelopmentManager.IsServerResponseEnabled(DevelopmentMode.Basic)) Debug.Log(\"ServerExampleResponse is handling a account creation complete type\"); messageWasParsedSucessfully = response.TryGetValue(\"response\", TokenType.DataDictionary, out HandleResult); } else if (Type == ServerResponseType.Item_Updated) { if (DevelopmentManager.IsServerResponseEnabled(DevelopmentMode.Basic)) Debug.Log(\"ServerExampleResponse is handling a item update type\"); //Server sends message with a string response so this will display the bits remaining until item adding/remove message completion messageWasParsedSucessfully = response.TryGetValue(\"response\", TokenType.String, out HandleResult); } else if (Type == ServerResponseType.Added_Item) { if (DevelopmentManager.IsServerResponseEnabled(DevelopmentMode.Basic)) Debug.Log(\"ServerExampleResponse is handling a Added item type\"); messageWasParsedSucessfully = response.TryGetValue(\"response\", TokenType.DataList, out HandleResult); } else if (Type == ServerResponseType.Removed_Item) { if (DevelopmentManager.IsServerResponseEnabled(DevelopmentMode.Basic)) Debug.Log(\"ServerExampleResponse is handling a Removed item type\"); messageWasParsedSucessfully = response.TryGetValue(\"response\", TokenType.DataList, out HandleResult); } return !messageWasParsedSucessfully; } } Now that I have something that will store the response from the server, I can continue onto modifying my \"ExampleDatabaseConnector\" to handle this ServerResponse : /// <summary> /// The field used to display all the user's items /// </summary> public Text itemField; /// <summary> /// The field used to display the server's responses to the user /// </summary> public Text responseField; /// <summary> /// The server response handler to be used for this example /// </summary> public ExampleServerResponse ExampleResponseParser; private DataList items = new DataList(); /// <summary> /// Take a UserSchema and setup the display for the data /// </summary> /// <param name=\"userData\"> The user data to use with the setup </param> private void SetupUserData(DataToken userData) { //This is basically the same as the user schema on the server but in C# if (!UserSchema.IsUserSchema(userData, out DataDictionary userSchema)) { if (DevelopmentManager.IsConnectorEnabled(DevelopmentMode.Basic)) Debug.Log(\"Trying to setup user data with invalid data, is not UserSchema\"); return; } currency = InvetorySchema.GetCurrency(userData); items.Clear(); items = InvetorySchema.GetInventoryItems(userData); RenderInventoryText(); } /// <summary> /// Renders out the inventory to the display /// </summary> private void RenderInventoryText() { itemField.text = $\"Currency: {currency}\\n\"; for (int i = 0; i < items.Count; i++) { itemField.text += $\"Item {i}: {ItemSchema.GetItemID(items[i])}\\n\"; } } /// <summary> /// Accept any responses from the server and handle them /// </summary> /// <param name=\"response\"> The response from the server </param> public override void HandleMessage(string response) { if (DevelopmentManager.IsConnectorEnabled(DevelopmentMode.Basic)) Debug.Log(\"Server message has been recieved and is being handled by example connector\"); ExampleResponseParser.Parse(response, out DataToken HandlerResult); switch (ExampleResponseParser.Type) { case ServerResponseType.Login_Updated: responseField.text = $\"Recieved a login update message with the response: {HandlerResult.String}\"; break; case ServerResponseType.Login_Complete: SetupUserData(ExampleResponseParser.Content); responseField.text = $\"Recieved a login complete message with the response: {UserSchema.GetLoginHash(HandlerResult.DataDictionary)}\"; break; case ServerResponseType.Login_Failed: responseField.text = $\"Recieved a login failed message with the response: {HandlerResultString}\"; break; case ServerResponseType.Account_Creation_Complete: responseField.text = $\"Recieved a account creation succeeded message with the response:{UserSchema.GetLoginHash(HandlerResult.DataDictionary)}\"; break; case ServerResponseType.Added_Item: if (ExampleResponseParser.Content.TokenType == TokenType.DataList) { for (int i = 0; i < ExampleResponseParser.Content.DataList.Count; i++) { items.Add(ExampleResponseParser.Content.DataList[i].DataDictionary); } } else { if (DevelopmentManager.IsConnectorEnabled(DevelopmentMode.Basic)) Debug.Log(\"Server response has returned with an add item type but the message was in a incorrect format\"); } responseField.text = $\"Recieved a add item message adding items: {HandlerResult.DataList.Count}\"; RenderInventoryText(); break; case ServerResponseType.Removed_Item: if (ExampleResponseParser.Content.TokenType == TokenType.DataList) { for (int i = 0; i < ExampleResponseParser.Content.DataList.Count; i++) { if (Convert.ToInt32(ExampleResponseParser.Content.DataList[i].Double) < items.Count) items.RemoveAt(Convert.ToInt32(ExampleResponseParser.Content.DataList[i].Double)); } } else { if (DevelopmentManager.IsConnectorEnabled(DevelopmentMode.Basic)) Debug.Log(\"Server response has returned with an remove item type but the message was in a incorrect format\"); } responseField.text = $\"Recieved a remove item message removing items: {HandlerResult.DataList.Count}\"; RenderInventoryText(); break; default: if (DevelopmentManager.IsConnectorEnabled(DevelopmentMode.Basic)) Debug.Log(\"Server response has returned with an unhandle type: \" + ExampleResponseParser.Type); responseField.text = \"Recieved an invalid message response type\"; break; } } And that's it, I can now link up the text fields and whenever the \"ExampleDatabaseConnector\" recieves a message it should render it to a display that makes sense for the user Final Thoughts This was kind of complicated to implement, however once you have a single bit of logic built, you can copy and paste a lot of the code into other logic to expand on this greatly. Next Steps As you might have noticed, I have left out the currency value from the example, why don't you try to use what I've shown above and implement a way to increase/decrease/set this value and have it be displayed on the user's side."
  },
  "example/Server.html": {
    "href": "example/Server.html",
    "title": "Configuring Server Settings | Server Connector documentation",
    "keywords": "Configuring Server Settings Server Environment File The node server requires a .env file inside the base folder with the following configuration Setting Value Type Description PORT String This is the port that the NodeJS server will listen to requests on MESSAGE_TYPE_BITS Int This is the bit length used for determining a message's type MESSAGE_BITS_LENGTH Int This is the bit length of the entire message (including MESSAGE_TYPE_BITS) DATABASE_URL String The URL of the database, for example \"mongodb+srv:// . .mongodb.net/**\" DATABASE_NAME String The name of the MongoDB collection to be used for the Database DATABASE_CONNECTION_TIMEOUT Int The total time in MS until a stalled database connection fails DATABASE_USER_CERT String The location (relative to initial folder) of the MongoDB login certificate LOGIN_HASH_CHARACTERS Int This is the length required for a VRC user's login to the database PRUNE_INACTIVE_TIME_MINUTES String Controls how long a VRC user has to not message for them to be pruned(removed) from the connect user storage DEVELOPMENT_MODE String Controls if logging should be enable on the server for example: PORT=33646 MESSAGE_TYPE_BITS=4 MESSAGE_BITS_LENGTH=21 DATABASE_URL=\"mongodb+srv://xxxx.xxxx.mongodb.net/RPGDatabase\" DATABASE_NAME=\"RPGDatabase\" DATABASE_CONNECTION_TIMEOUT=2000 DATABASE_USER_CERT=\"Mongodb/mongo.pem\" LOGIN_HASH_CHARACTERS=9 PRUNE_INACTIVE_TIME_MINUTES=30 DEVELOPMENT_MODE=true Modifying The Server's Listening URL By default the server will listen for any messages that start with \"/sendMessage=\", however, this can be changed by modifying line 52 inside the App.js file: Remember to keep the * wildcard at the end otherwise the server will only listen to the exact URL \"/sendMessage=\" //ignore favicon app.use(\"/favicon.ico\", function() {}); //Bind all messages to custom server logic app.use('/sendMessage=*', ServerConnector.HandleConnection); // <----- Change this line here // catch 404 and forward to error handler app.use(function(req, res, next) { next(createError(404)); }); Don't forget to update the VRC URL settings"
  },
  "example_api/Joshf67.ServerConnector.Example.ExampleDatabaseConnector.html": {
    "href": "example_api/Joshf67.ServerConnector.Example.ExampleDatabaseConnector.html",
    "title": "Class ExampleDatabaseConnector | Server Connector documentation",
    "keywords": "Class ExampleDatabaseConnector Example connector to show how to connect to a databse and read/update values Inheritance Object ExampleDatabaseConnector Namespace : Joshf67.ServerConnector.Example Assembly : cs.temp.dll.dll Syntax public class ExampleDatabaseConnector : Connector Fields AddItemField The field used to accept inputs for item addition messages Declaration public InputField AddItemField Field Value Type Description InputField ExampleResponseParser The server response handler to be used for this example Declaration public ExampleServerResponse ExampleResponseParser Field Value Type Description ExampleServerResponse hasher Used to hash any messages for simple encryption Declaration protected UdonHashLib hasher Field Value Type Description UdonHashLib itemField The field used to display all the user's items Declaration public Text itemField Field Value Type Description Text passwordField The field used to accept password inputs for account messages Declaration public InputField passwordField Field Value Type Description InputField RemoveItemField The field used to accept inputs for item removal messages Declaration public InputField RemoveItemField Field Value Type Description InputField responseField The field used to display the server's responses to the user Declaration public Text responseField Field Value Type Description Text usernameField The field used to accept login inputs for account messages Declaration public InputField usernameField Field Value Type Description InputField Methods AddItem() Queue up an add item message to the server and attempt to add it Declaration public void AddItem() ConvertSHA256ToMessage(String) Convert a SHA256 hash into a shorter 9 character hash to decrease login message time, This decreases the security and increase the chance of collision but due to 2.5s rate limiting this is required to make it reasonable Declaration public string ConvertSHA256ToMessage(string hash) Parameters Type Name Description String hash The string to hash Returns Type Description String A 9 character string message of the hashed value ConvertTextToHash(String) Converts a text to SHA512 using UdonHashLib Declaration public string ConvertTextToHash(string text) Parameters Type Name Description String text The text to convert Returns Type Description String A SHA512 hash of the text CreateAccount() Queue up a create account message to the server and attempt to create an account Declaration public void CreateAccount() HandleMessage(String) Accept any responses from the server and handle them Declaration public override void HandleMessage(string response) Parameters Type Name Description String response The response from the server Login() Queue up login messages to send to the server and attempt to log in Declaration public void Login() RemoveItem() Queue up a remove item message to the server and attempt to remove it Declaration public void RemoveItem()"
  },
  "example_api/Joshf67.ServerConnector.Example.ExampleServerResponse.html": {
    "href": "example_api/Joshf67.ServerConnector.Example.ExampleServerResponse.html",
    "title": "Class ExampleServerResponse | Server Connector documentation",
    "keywords": "Class ExampleServerResponse Example response to show how to handle server responses Inheritance Object ExampleServerResponse Namespace : Joshf67.ServerConnector.Example Assembly : cs.temp.dll.dll Syntax public class ExampleServerResponse : ServerResponse Methods HandleResponse(DataDictionary, out DataToken) Handles the parsed message Declaration protected override bool HandleResponse(DataDictionary response, out DataToken HandleResult) Parameters Type Name Description DataDictionary response The JSON DataDictionary to be handled DataToken HandleResult The result of the ServerRespons handler Returns Type Description Boolean Boolean if the response was parsed properly"
  },
  "example_api/Joshf67.ServerConnector.Example.html": {
    "href": "example_api/Joshf67.ServerConnector.Example.html",
    "title": "Namespace Joshf67.ServerConnector.Example | Server Connector documentation",
    "keywords": "Namespace Joshf67.ServerConnector.Example Classes ExampleDatabaseConnector Example connector to show how to connect to a databse and read/update values ExampleServerResponse Example response to show how to handle server responses InvetorySchema Allows easy parsing of a User's Inventory data through helper functions ItemSchema Allows easy parsing of a User's item data through helper functions UdonHashLib UdonHashLib created by (Gorialis) R UserSchema Allows easy parsing of a User's data through helper functions"
  },
  "example_api/Joshf67.ServerConnector.Example.InvetorySchema.html": {
    "href": "example_api/Joshf67.ServerConnector.Example.InvetorySchema.html",
    "title": "Class InvetorySchema | Server Connector documentation",
    "keywords": "Class InvetorySchema Allows easy parsing of a User's Inventory data through helper functions Inheritance Object InvetorySchema Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Joshf67.ServerConnector.Example Assembly : cs.temp.dll.dll Syntax public static class InvetorySchema Methods GetCurrency(DataToken) Get the currency for a user Declaration public static double GetCurrency(DataToken data) Parameters Type Name Description DataToken data The user to get the currency for Returns Type Description Double The user's currency GetCurrency(DataToken, out Double) Get the currency for a user/inventory Declaration public static bool GetCurrency(DataToken data, out double currency) Parameters Type Name Description DataToken data The user/inventory to get the currency for Double currency The resulting user's currency Returns Type Description Boolean Boolean if the user's currency exists GetInventoryItems(DataToken) Get the items for a user/inventory Declaration public static DataList GetInventoryItems(DataToken data) Parameters Type Name Description DataToken data The user/inventory to get the inventory items for Returns Type Description DataList The user's inventory items GetInventoryItems(DataToken, out DataList) Get the items for a user/inventory Declaration public static bool GetInventoryItems(DataToken data, out DataList items) Parameters Type Name Description DataToken data The user/inventory to get the inventory items for DataList items The resulting user's inventory items Returns Type Description Boolean Boolean if the user's inventory items exists IsInventorySchema(DataToken, out DataDictionary) Test if a DataDictionary is actually an Inventory schema Declaration public static bool IsInventorySchema(DataToken data, out DataDictionary inventorySchema) Parameters Type Name Description DataToken data The DataDictionary to test DataDictionary inventorySchema The DataDictionary restult if this is a InventorySchema Returns Type Description Boolean Boolean if the DataDictionary is a Inventory schema"
  },
  "example_api/Joshf67.ServerConnector.Example.ItemSchema.html": {
    "href": "example_api/Joshf67.ServerConnector.Example.ItemSchema.html",
    "title": "Class ItemSchema | Server Connector documentation",
    "keywords": "Class ItemSchema Allows easy parsing of a User's item data through helper functions Inheritance Object ItemSchema Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Joshf67.ServerConnector.Example Assembly : cs.temp.dll.dll Syntax public static class ItemSchema Methods GetItemID(DataToken) Get the ItemID for an item Declaration public static double GetItemID(DataToken data) Parameters Type Name Description DataToken data The item to get the ItemID for Returns Type Description Double The Item's ItemID GetItemID(DataToken, out Double) Get the ItemID for an item Declaration public static bool GetItemID(DataToken data, out double itemID) Parameters Type Name Description DataToken data The item to get the ItemID for Double itemID The resulting ItemID Returns Type Description Boolean Boolean if the ItemID exists IsItemSchema(DataToken, out DataDictionary) Test if a DataDictionary is actually a item schema Declaration public static bool IsItemSchema(DataToken data, out DataDictionary itemSchema) Parameters Type Name Description DataToken data The DataDictionary to test DataDictionary itemSchema The DataDictionary restult if this is a ItemSchema Returns Type Description Boolean Boolean if the DataDictionary is a item schema"
  },
  "example_api/Joshf67.ServerConnector.Example.UdonHashLib.html": {
    "href": "example_api/Joshf67.ServerConnector.Example.UdonHashLib.html",
    "title": "Class UdonHashLib | Server Connector documentation",
    "keywords": "Class UdonHashLib UdonHashLib created by (Gorialis) R Inheritance Object UdonHashLib Namespace : Joshf67.ServerConnector.Example Assembly : cs.temp.dll.dll Syntax public class UdonHashLib : UdonSharpBehaviour Methods MD5_Bytes(Byte[]) Declaration public string MD5_Bytes(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description String MD5_UTF8(String) Declaration public string MD5_UTF8(string text) Parameters Type Name Description String text Returns Type Description String SHA1_Bytes(Byte[]) Declaration public string SHA1_Bytes(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description String SHA1_UTF8(String) Declaration public string SHA1_UTF8(string text) Parameters Type Name Description String text Returns Type Description String SHA224_Bytes(Byte[]) Declaration public string SHA224_Bytes(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description String SHA224_UTF8(String) Declaration public string SHA224_UTF8(string text) Parameters Type Name Description String text Returns Type Description String SHA256_Bytes(Byte[]) Declaration public string SHA256_Bytes(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description String SHA256_UTF8(String) Declaration public string SHA256_UTF8(string text) Parameters Type Name Description String text Returns Type Description String SHA384_Bytes(Byte[]) Declaration public string SHA384_Bytes(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description String SHA384_UTF8(String) Declaration public string SHA384_UTF8(string text) Parameters Type Name Description String text Returns Type Description String SHA512_Bytes(Byte[]) Declaration public string SHA512_Bytes(byte[] data) Parameters Type Name Description Byte [] data Returns Type Description String SHA512_UTF8(String) Declaration public string SHA512_UTF8(string text) Parameters Type Name Description String text Returns Type Description String"
  },
  "example_api/Joshf67.ServerConnector.Example.UserSchema.html": {
    "href": "example_api/Joshf67.ServerConnector.Example.UserSchema.html",
    "title": "Class UserSchema | Server Connector documentation",
    "keywords": "Class UserSchema Allows easy parsing of a User's data through helper functions Inheritance Object UserSchema Inherited Members Object.ToString() Object.Equals(Object) Object.Equals(Object, Object) Object.ReferenceEquals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Namespace : Joshf67.ServerConnector.Example Assembly : cs.temp.dll.dll Syntax public static class UserSchema Methods GetInventory(DataToken) Get the inventory for a user Declaration public static DataDictionary GetInventory(DataToken data) Parameters Type Name Description DataToken data The user to get the inventory for Returns Type Description DataDictionary The user's inventory GetInventory(DataToken, out DataDictionary) Get the inventory for a user Declaration public static bool GetInventory(DataToken data, out DataDictionary inventory) Parameters Type Name Description DataToken data The user to get the inventory for DataDictionary inventory The resulting user's inventory Returns Type Description Boolean Boolean if the user inventory exists GetLoginHash(DataToken) Get the login hash for a user Declaration public static string GetLoginHash(DataToken data) Parameters Type Name Description DataToken data The user to get the hash for Returns Type Description String The user's login hash GetLoginHash(DataToken, out String) Test and Get the login hash for a user Declaration public static bool GetLoginHash(DataToken data, out string loginHash) Parameters Type Name Description DataToken data The user to get the hash for String loginHash The resulting user's login hash Returns Type Description Boolean Boolean if the user login hash exists IsUserSchema(DataToken, out DataDictionary) Test if a DataDictionary is actually a user schema Declaration public static bool IsUserSchema(DataToken data, out DataDictionary userSchema) Parameters Type Name Description DataToken data The DataDictionary to test DataDictionary userSchema The DataDictionary restult if this is a UserSchema Returns Type Description Boolean Boolean if the DataDictionary is a user schema"
  },
  "index.html": {
    "href": "index.html",
    "title": "VRC Server Connector Introduction | Server Connector documentation",
    "keywords": "VRC Server Connector Introduction Skip to the API explanation? Go to the Github Repository? What? VRC Server Connector is an API that allows your to send and recieve arbitrary messages to/from external servers. Why? VRC does not allow arbitrary amounts of data out of the VRC client easily, this has affected some of the functionality of worlds by limiting them to only being capable of downloading data from a server (using the Video Player or String / Image loading) through static URLs or user entered URLs . The community has already come up with methods to bypass these limitations locally, however, these all come with their own downsides that a creator has to account for ( this API also has downsides ): AvatarImageReader (depricated) How? An external NodeJS server is set up to listen to requests from String / Image loading and converts the URL into the binary equivilent. This is then parsed based on the logic implemented on the server, the server then responds to the VRC loader request with an appropriate response that is then parsed on the VRC client side using UdonJSON and handled. Positives Can send arbitrary data out of VRC to an externally hosted server, which means that users are not able to tamper with the data directly. Data can be compressed and arbirary length of bits can be used to decrease the required messages being sent. The server is not coupled to the world, so you can connect to a single external server from multiple VRC worlds. Uses VRC features under the hood, so should be inherently cross-compatible. Negatives Relies on IP address to reference user which means any user in a location that has multiple connections from the same IP will collide with eachother's messages and fail to work. Due to relying on the String / Image under the hood, the upload rate is very slow. Using the default message length of 21 bits, each loader used has an effective rate of ~4 bits/s (initial overheads means longer messages are more efficient), as you can see this is very limited on what you can send so you need to be clever with your requests. Small messages are not optimized due to the String loader being required for the first and last message to read the response. Each bit of data that you want to send needs to be accounted for as a VRCUrl. This means that larger message sizes require exponentially more VRCUrls. This increases world build times and will increase the world filesize, From some initial tests each VRCUrl takes 0.02ms and 1.15 bytes to build . Handling individual bits and trying to communicate with limited bandwidth requires some creative thinking and is not a drag-and-drop solution, this can become very complex very fast. Future Development? Currently the Video Player is unused, if this was implemented the upload speed could be increased to ~63 bits per 5s (~12 bits/s) or even ~84 bits if both Video Player could be combined. Currently only the String loader is used to handle responses, this means the first and last requests require it, so you have to wait 5s for them before starting a new message, and other slowdowns due to this. Converting Objects aren't supported the best, this may cause some issues with custom data types that cannot fit inside DataTokens. Credits: Gorialis - UdonHashLib used for hashing login data in the example project Hax - For the initial MessagePacker script, original FFMPEG response (no longer used), general help and suggestions on methods to use @Merlin - Creating UdonSharp and for general help with bugs/issues @GlitchyDev, @Miner28 and @BocuD - AvatarImageReader code to read in data from a render texture (old video player method, no longer used, but thanks is still deserved) The U# Discord for everyone that has made any suggestions or comments during the development of this API"
  },
  "manual/APIIntroduction.html": {
    "href": "manual/APIIntroduction.html",
    "title": "VRC Server Connector API Introduction | Server Connector documentation",
    "keywords": "VRC Server Connector API Introduction All of the API code is documented here , however, here is a brief overview of the most common parts of the API that you will interact with: ServerConnector This is the class that you will inherit from if you want to build upon helper functions that allow messages to and from the external server by overriding the HandleMessage method. ServerResponse This is the class that you will inherit from if you want to handle server responses by overriding the HandleResponse method. MessagePacker This static class is probably what you will interact with when converting your data into compressed messages that the URL packer will use. To pack a set of data into a URL message buffer, you need to provide the method PackMessageBytesToURL with a DataList of preferably pre-compressed messages, however, this function will try to convert inputs into a compressed format (this might not be optimized for your use case). To compress messages you will want to call the static function CompressMessage with a DataToken , (optional) the amount of bits you want from the message and finally (optional) the type of packing you want to use for the message. ByteConverter If you are interacting with this manually then it's probably because you want manually convert values into their bytes, the API reference will give you all the methods available."
  },
  "manual/Server.html": {
    "href": "manual/Server.html",
    "title": "Configuring Server Settings | Server Connector documentation",
    "keywords": "Configuring Server Settings Server Environment File The node server requires a .env file inside the base folder with the following configuration Setting Value Type Description PORT String This is the port that the NodeJS server will listen to requests on MESSAGE_TYPE_BITS Int This is the bit length used for determining a message's type MESSAGE_BITS_LENGTH Int This is the bit length of the entire message (including MESSAGE_TYPE_BITS) PRUNE_INACTIVE_TIME_MINUTES String Controls how long a VRC user has to not message for them to be pruned(removed) from the connect user storage DEVELOPMENT_MODE String Controls if logging should be enable on the server for example: PORT=33646 MESSAGE_TYPE_BITS=4 MESSAGE_BITS_LENGTH=21 PRUNE_INACTIVE_TIME_MINUTES=30 DEVELOPMENT_MODE=true Modifying The Server's Listening URL By default the server will listen for any messages that start with \"/sendMessage=\", however, this can be changed by modifying line 52 inside the App.js file: Remember to keep the * wildcard at the end otherwise the server will only listen to the exact URL \"/sendMessage=\" //ignore favicon app.use(\"/favicon.ico\", function() {}); //Bind all messages to custom server logic app.use('/sendMessage=*', ServerConnector.HandleConnection); // <----- Change this line here // catch 404 and forward to error handler app.use(function(req, res, next) { next(createError(404)); }); Don't forget to update the VRC URL settings"
  },
  "manual/VRC.html": {
    "href": "manual/VRC.html",
    "title": "Configuring VRC Settings | Server Connector documentation",
    "keywords": "Configuring VRC Settings There are two methods to generate the URLs for the connection: ConnectorUrl Tool Inspector In order to use this tool you need to add it to a GameObject and supply the starting URL and the total URLs to generate. Once you supply the required parameters a \"Generate URLs\" button will appear, this will generate all of the VRCUrls required and set up the URL containers for the GameObject inside a child GameObject that will be named \"0 - URL count\". Do not inspect the named child GameObject as for optimisation this tool will generate 1 ConnectorURLTool component for every 8192 URLs, which will cause your editor to lock up until it loads them There is a helper button for calculating the total URLs required for a 21 bit message, if you are using a custom message length then please calulate the required URLs to fit your bits required: $(2^MESSAGE_BITS_LENGTH) $$ ConnectorUrl Tool Window In order to use this tool you need open the window by clicking on \"Server Connector\" in the top toolbar, as this is a object independent version of the ConnectorUrl Tool Inspector (see link for the parameters) you need to also supply the object to create the URLs under."
  },
  "manual/VRCUrlTesting.html": {
    "href": "manual/VRCUrlTesting.html",
    "title": "VRCUrl impact testing | Server Connector documentation",
    "keywords": "VRCUrl impact testing Return to negatives Tested on: CPU: 5800x3d GPU: RTX 4090 Starting URL (38 characters) = \"http//***.***.*.***:*****/sendMessage=\" 21 bit message lengths = 2097152 VRCUrls: File size: 2.65MB Build time: 2 minutes 10 seconds 20 bit message lengths = 1048576 VRCUrls: File size: 1.44MB Build time: 1 minutes 48 seconds None: File size: 212.87kb Build time: 41 seconds Assuming linear scaling (which is probably innacurate) 1 VRCUrl: File size: 1.15 bytes Build time: 0.02ms"
  }
}